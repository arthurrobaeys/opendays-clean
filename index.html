<!doctype html>
<html lang="en">
<head>
	<title>Video Texture (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="style.css"/>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="Three.js/js/Detector.js"></script>
<script src="Three.js/js/Stats.js"></script>
<script src="Three.js/js/OrbitControls.js"></script>
<script src="Three.js/js/THREEx.KeyboardState.js"></script>
<script src="Three.js/js/THREEx.FullScreen.js"></script>
<script src="Three.js/js/THREEx.WindowResize.js"></script>
<script src='Three.js/js/threex.domevents.js'></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js" integrity="sha512-lIKG1kC5TMb1Zx32vdz1n31YJMZRknVY20U9MJ28hD3y2c0OKN0Ce5NhJji78v8zX5UOSsm+MTBOcJt7yMBnSg==" crossorigin="anonymous"></script>



<div class="ui">
	<div class="topbar-wrapper">
		<ul class="list">
			<li class="listitem">click card: play/pause</li>
			<li class="listitem">S: restart video</li>
			<li class="listitem">R: rewind video</li>
		</ul>
		<div class="mute-div">
			<p class="mute-label">Sound on</p>
			<img src="Three.js/images//volume.svg" alt="mute/unmute" class="mute-btn">
		</div>
	</div>
</div>

<div class="threeJS" id="ThreeJS"></div>
<!-- <video id="skyVideo" src="Three.js/videos/sky-vid-reduced.mp4" type="video/mp4" playsinline autoplay muted loop></video> -->

<script>
	
// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();

// custom global variables
var video, videoImage, videoImageBg, videoImageContext, videoTexture, card, cardGeo, floorTexture, bgTexture, cardMaterial, cardCamera, cardPosition, cloudGeo, cloudMaterial;
var rotation = true, playing = false;
var shine = 30;
let cloudParticles = [];

init();
animate();

// FUNCTIONS 		
function init() 
{

	//UI INTERACTION
	const mute = document.querySelector('.mute-btn');
	const muteLabel = document.querySelector('.mute-label');
	mute.addEventListener('click', function muteVideo(event){

    if (video.muted === true) {
      video.muted = false;
	  mute.src = "Three.js/images/volume.svg";
	  muteLabel.textContent = "Sound on";
    }
    else{
      video.muted = true;
	  mute.classList.remove('muted');
	  mute.src = "Three.js/images/volume-x.svg"
	  muteLabel.textContent = "Sound off";
    }
	})

	// OFFSET FUNCTION
	const randomOffsetVal = (value) => {
	  return value + Math.floor(Math.random() * 10000) * 0.000001;
	}

	let loader = new THREE.TextureLoader();

	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 5000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);

	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true, alpha: true} );
	else
		renderer = new THREE.CanvasRenderer(); 

	//LOGGING PERFORMANCE
	console.log("Scene polycount:", renderer.info.render.triangles)
	console.log("Active Drawcalls:", renderer.info.render.calls)
	console.log("Textures in Memory", renderer.info.memory.textures)
	console.log("Geometries in Memory", renderer.info.memory.geometries)
		
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	//blurring off but a big drop in fps
	//renderer.setPixelRatio( window.devicePixelRatio );
	renderer.shadowMap.enabled = true;
	renderer.shadowMapSoft = true;
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );

		// EVENTS
		var domEvents = new THREEx.DomEvents( camera, renderer.domElement);

//see if video is playing, add property
Object.defineProperty(HTMLMediaElement.prototype, 'playing', {
get: function(){
	return !!(this.currentTime > 0 && !this.paused && !this.ended && this.readyState > 2);
}
})

	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );

	// LIGHT

	let ambient = new THREE.AmbientLight(0x555555, .5);
    scene.add(ambient);

	var light = new THREE.PointLight(0xffffff, .6, 0, 2);
	light.position.set(0,500,0);

	var faceLight = new THREE.DirectionalLight(0xffffff, .06);
	faceLight.position.set(0,100,500);

	var directionalLight = new THREE.DirectionalLight( 0xffffff, 1, 0, 2 );
	directionalLight.castShadow = true;
	directionalLight.position.set(0, 600, 600);
	directionalLight.shadow.camera.left = -500;
directionalLight.shadow.camera.right = 500;
directionalLight.shadow.camera.top = 500;
directionalLight.shadow.camera.bottom = -500;

directionalLight.shadow.radius = 2;
directionalLight.shadow.camera.near = 0;
directionalLight.shadow.camera.far = 1200;
directionalLight.shadow.mapSize.width = 2048; // default is 512
directionalLight.shadow.mapSize.height = 2048; // default is 512

	scene.add(light);
	scene.add(directionalLight);
	scene.add(faceLight);

	const cameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
	//scene.add(cameraHelper);

	// FLOOR
	floorTexture = loader.load( "Three.js/images/tegels-small@4x.png" );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshPhongMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneBufferGeometry(10000, 10000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.receiveShadow = true;
	floor.position.y = -0.5;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

	// SKY

	renderer.setClearColor(0x4e6cff); //light blue sky
	cloudGeo = new THREE.PlaneBufferGeometry(2360,984);


	const texMap = loader.load('Three.js/images/smoke.png');
	const testMat = new THREE.MeshBasicMaterial({map: texMap, transparent: true});
	

 	for(let p=0; p<50; p++) {
	let testCloud = new THREE.Mesh(cloudGeo, testMat);
   testCloud.position.set(
     Math.random()*10000 -5000,
     Math.random()*2000 + 200,
     randomOffsetVal(Math.random()*2000-3000)
   );
//    testCloud.rotation.x = 1.16;
//    testCloud.rotation.y = -0.12;
//    testCloud.rotation.z = Math.random()*2*Math.PI;
   testCloud.material.opacity = 0.30;
   cloudParticles.push(testCloud);
   scene.add(testCloud);
 }

	// SKYBOX/FOG
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
 //scene.add(skyBox);
	scene.fog = new THREE.FogExp2( 0xffffff, 0.00050 );
	
	
	///////////
	// VIDEO //
	///////////
	
	// create the video element
	video = document.createElement( 'video' );
	// video.id = 'video';
	// video.type = ' video/ogg; codecs="theora, vorbis" ';
	video.src = "Three.js/videos/ShelterStore - story_2.mp4";
	video.load(); // must call after setting/changing source
	
	// alternative method -- 
	// create DIV in HTML:
	// <video id="myVideo" autoplay style="display:none">
	//		<source src="videos/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
	// </video>
	// and set JS variable:
	// video = document.getElementById( 'myVideo' );
	
	videoImage = document.createElement( 'canvas' );
	videoImage.width = 1080;
	videoImage.height = 1920;

	videoImageContext = videoImage.getContext( '2d' );
	// background color if no video present
	var grd = videoImageContext.createLinearGradient(0, 0, 0, 1000);
	grd.addColorStop(0, "silver");
	grd.addColorStop(1, "white");

	videoImageContext.fillStyle = grd;
	videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );

	videoTexture = new THREE.VideoTexture( videoImage );
	videoTexture.minFilter = THREE.LinearFilter;
	videoTexture.magFilter = THREE.LinearFilter;

	// the geometry on which the movie will be displayed;
	// 		movie image will be scaled to fit these dimensions.

// 	const materials = [
// 		new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true} ),
// 	new THREE.MeshBasicMaterial({map: loader.load('Three.js/images/_Deliverables_Cards Peepshow2.jpg')}),
// 	new THREE.MeshBasicMaterial({map: loader.load('Three.js/images/_Deliverables_Cards Peepshow2.jpg')}),
// 	new THREE.MeshBasicMaterial({map: loader.load('Three.js/images/_Deliverables_Cards Peepshow2.jpg')}),
// 	new THREE.MeshBasicMaterial({map: loader.load('Three.js/images/_Deliverables_Cards Peepshow2.jpg')}),
// 	new THREE.MeshBasicMaterial({map: loader.load('Three.js/images/_Deliverables_Cards Peepshow2.jpg')}),
// ];

	cardCamera = new THREE.CubeCamera(1, 5000, 512);
    cardCamera.position.set(0, 150, 400);

	scene.add(cardCamera);

	cardGeo = new THREE.PlaneBufferGeometry( 108, 192);

	const backTexture = new THREE.TextureLoader().load( "Three.js/images/backside-card.jpg");

	var frontMaterial = new THREE.MeshPhongMaterial( { map: videoTexture, envMap: cardCamera.renderTarget, side:THREE.FrontSide, shininess: shine, reflectivity: 0.1, specular:0xffffff } );
	var backMaterial = new THREE.MeshPhongMaterial( { map: backTexture, side: THREE.BackSide, shininess: shine, specular:0xffffff } );

	card = new THREE.Group();

	cardFront = new THREE.Mesh( cardGeo, frontMaterial );
	cardBack = new THREE.Mesh( cardGeo, backMaterial );

	card.add(cardFront);
	card.add(cardBack);

	card.position.set(0,100,0);

	card.castShadow = true;
 	 card.receiveShadow = true;
	scene.add(card);
	directionalLight.target = card;
	faceLight.target = card;


	camera.position.set(0,150,500);
	camera.lookAt(card.position);

	var domEvents = new THREEx.DomEvents(camera, renderer.domElement);
domEvents.addEventListener(card, 'mousedown', onDocumentMouseDown, false);

function onDocumentMouseDown(event){
	console.log(event);
    if (event.target == card){
        if(video.playing){
		 video.pause();
		 var tween = new TWEEN.Tween(card.position).to({x: 0, y:100, z:0}, 500, TWEEN.Easing.ElasticOut).start();
		 tween.easing(TWEEN.Easing.Quadratic.Out);
		 rotation = true;
		 cardFront.material.reflectivity = 0.1;
		 faceLight.intensity = 0.08;
}else{
	video.play();
	rotation = false;
	card.rotation.y = Math.PI*2;
	var tween = new TWEEN.Tween(card.position).to({x: 0, y:120, z:200}, 500, TWEEN.Easing.ElasticIn).start();
	tween.easing(TWEEN.Easing.Quadratic.In);
	faceLight.intensity = 0.01;
	cardFront.material.reflectivity = 0;
}
	}
}
				
	
}

function animate(time) 
{
	time*0.000001;
	const speed = .0015;
    const rot = time * speed;

	if(playing = false){
		video.pause();
	}

		//rotation card
		if(rotation){
		card.rotation.y = rot;
	}
	floorTexture.offset.y -= .008;

	//cloud movement
	cloudParticles.forEach(p => {
      p.position.x -=0.5;
	  p.rotation.z -= 0.0001;
   });

    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("s") ) // stop video
	{
		video.pause();
		video.currentTime = 0;
	}
	
	if ( keyboard.pressed("r") ) // rewind video
		video.currentTime = 0;
	
	//controls.update();
	TWEEN.update()
	stats.update();
}

function render(time) 
{	

	if ( video.readyState === video.HAVE_ENOUGH_DATA ) 
	{
		videoImageContext.drawImage( video, 0, 0 );
		if ( videoTexture ) 
			videoTexture.needsUpdate = true;
	}
	if(cardMaterial){
		cardMaterial.needsUpdate = true;
	}

	renderer.render( scene, camera );
	cardCamera.updateCubeMap( renderer, scene );
}

</script>

</body>
</html>
