<!doctype html>
<html lang="en">
<head>
	<title>Video Texture (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="style.css"/>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="Three.js/js/Detector.js"></script>
<script src="Three.js/js/Stats.js"></script>
<script src="Three.js/js/OrbitControls.js"></script>
<script src="Three.js/js/THREEx.KeyboardState.js"></script>
<script src="Three.js/js/THREEx.FullScreen.js"></script>
<script src="Three.js/js/THREEx.WindowResize.js"></script>
<script src='Three.js/js/threex.domevents.js'></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js" integrity="sha512-LF8ZB1iTwi4Qvkm4pekHG4a437Y9Af5ZuwbnW4GTbAWQeR2E4KW8WF+xH8b9psevV7wIlDMx1MH9YfPqgKhA/Q==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js" integrity="sha512-lIKG1kC5TMb1Zx32vdz1n31YJMZRknVY20U9MJ28hD3y2c0OKN0Ce5NhJji78v8zX5UOSsm+MTBOcJt7yMBnSg==" crossorigin="anonymous"></script>


<div class="loadingScreen">

	<div class="loadingWrapper">
		<img class="NG-bird" src="Three.js/images/site-logo-medium.png" alt="nightingale-logo-3D"></img>
	</div>
	<div class="loading"></div>
</div>


<div class="ui">
	<div class="topbar-wrapper">
		<ul class="list">
			<li class="listitem">click card: play/pause</li>
			<li class="listitem">S: restart video</li>
			<li class="listitem">R: rewind video</li>
		</ul>
		<div class="mute-div">
			<p class="mute-label">Sound on</p>
			<img src="Three.js/images//volume.svg" alt="mute/unmute" class="mute-btn">
		</div>
	</div>
</div>
<div>
	<p class="flip-btn">Flip Card</p>
</div>

<div class="threeJS" id="ThreeJS">
</div>

<script>
	
// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();

// custom global variables
var video, videoImage, videoImageBg, videoImageContext, videoTexture, card, cardGeo, floorTexture, bgTexture, cardMaterial, cardCamera, cardPosition, cloudGeo, cloudMaterial;
var rotation = true, playing = false;
var shine = 30;
let cloudParticles = [];
let cardFocus = false;
let lastClicked = null;
let rot;
const flipBtn = document.querySelector('.flip-btn');
flipBtn.style.display = 'none';
let RESOURCES_LOADED = false;
let LOADING_MANAGER = null;
var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 10000;

// loading screen
const loadingScreen = document.querySelector( '.loadingScreen' );

//vars for carrousel
let numOfCards = 30;
let carrousel = new THREE.Group();
let carrouselRadius = 550;

//card every 12 degrees
const radianInterval = (2* Math.PI) / numOfCards;
const centerPoint = ({x: 0, y: 100, z: 0});
const focusPoint = ({x: 0, y: 0, z:250});


init();
animate();

// FUNCTIONS 		
function init() 
{
	loadingManager = new THREE.LoadingManager();

	const loadBar = document.querySelector('.loading');

	loadingManager.onProgress = function(item, loaded,total){
		console.log(item,loaded,total);
		loadBar.style.width = (loaded / total * 30) + '%';
	}

	loadingManager.onLoad = function(){
		console.log('all cards loaded');
		RESOURCES_LOADED = true;
    	loadingScreen.classList.add( 'fade-out' );
		setTimeout(setDisplayNone, 5000);
	}

	const setDisplayNone = () => {
		loadingScreen.style.display = 'none';
		console.log('display off');
	}

	//UI INTERACTION
	const mute = document.querySelector('.mute-btn');
	const muteLabel = document.querySelector('.mute-label');
	mute.addEventListener('click', function muteVideo(event){

    if (video.muted === true) {
      video.muted = false;
	  mute.src = "Three.js/images/volume.svg";
	  muteLabel.textContent = "Sound on";
    }
    else{
      video.muted = true;
	  mute.classList.remove('muted');
	  mute.src = "Three.js/images/volume-x.svg"
	  muteLabel.textContent = "Sound off";
    }
	})

	// OFFSET FUNCTION
	const randomOffsetVal = (value) => {
	  return value + Math.floor(Math.random() * 10000) * 0.000001;
	}

	let loader = new THREE.TextureLoader(loadingManager);

	// SCENE
	scene = new THREE.Scene();
	// CAMERAS
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);

	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true,} );
	else
		renderer = new THREE.CanvasRenderer(); 

	//LOGGING PERFORMANCE
	console.log("Scene polycount:", renderer.info.render.triangles)
	console.log("Active Drawcalls:", renderer.info.render.calls)
	console.log("Textures in Memory", renderer.info.memory.textures)
	console.log("Geometries in Memory", renderer.info.memory.geometries)
		
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

	//PIXELRATIO
	renderer.setPixelRatio(1)
	 window.addEventListener("resize", function(){
	 	const pixelRatio = window.devicePixelRatio;
     const width  = window.innerWidth;
     const height = window.innerHeight
	 if(width < 600){
	 	renderer.setPixelRatio(2);
	 }else if(width < 900){
	 	renderer.setPixelRatio(1.5);
	 }
	 });


	// renderer.shadowMap.enabled = true;
	// renderer.shadowMapSoft = true;
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.enableZoom = false;

		// EVENTS
		var domEvents = new THREEx.DomEvents( camera, renderer.domElement);

//see if video is playing, add property
Object.defineProperty(HTMLMediaElement.prototype, 'playing', {
get: function(){
	return !!(this.currentTime > 0 && !this.paused && !this.ended && this.readyState > 2);
}
})

	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );

	// LIGHT

	const nav = document.querySelector('.ui');
	nav.style.display = 'none';

	const datGui  = new dat.GUI({ autoPlace: true });
	datGui.domElement.id = 'gui';


	let ambient = new THREE.AmbientLight(0x555555, 1.5);
    scene.add(ambient);

	var light = new THREE.PointLight(0xffffff, 1.26);
	light.position.set(0,6789,2000);


	let lightTarget = new THREE.Object3D();
	lightTarget.position.set(0, 100, 700);
	scene.add(lightTarget);

	const spotLight = new THREE.SpotLight( 0xffffff, 1, 1000, Math.PI/4 );
	spotLight.position.set( 0, 135, 2000 );

	spotLight.target = lightTarget;


	spotLight.shadow.mapSize.width = 1024;
	spotLight.shadow.mapSize.height = 1024;

	spotLight.shadow.camera.near = 0;
	spotLight.shadow.camera.far = 500;
	spotLight.shadow.camera.fov = 45;

	scene.add( spotLight );
	scene.add(light);

	var posL = datGui.addFolder('position light');
	posL.add(light.position, 'x', 0, 1000);
	posL.add(light.position, 'y', -2000, 10000);
	posL.add(light.position, 'z', -2000, 2000);
	posL.add(light, 'intensity', 0, 10, 0.01);

	var posL2 = datGui.addFolder('position light2');
	posL2.add(spotLight.position, 'x', -1000, 1000);
	posL2.add(spotLight.position, 'y', -2000, 2000);
	posL2.add(spotLight.position, 'z', -2000, 2000);
	posL2.add(spotLight, 'intensity', 0, 10, 0.01);

	// FLOOR
	floorTexture = loader.load( "Three.js/images/tile-seamless-big.png" );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshStandardMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneBufferGeometry(10000, 10000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.receiveShadow = true;
	floor.position.y = -0.5;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

	// SKY

	//renderer.setClearColor(0x4e6cff); //light blue sky
	cloudGeo = new THREE.PlaneBufferGeometry(2360,984);


	const texMap = loader.load('Three.js/images/smoke.png');
	const testMat = new THREE.MeshBasicMaterial({map: texMap, transparent: true});
	

 	for(let p=0; p<500; p++) {
	let testCloud = new THREE.Mesh(cloudGeo, testMat);
   testCloud.position.set(
     Math.random()*10000 -5000,
     Math.random()*6000 + 200,
     randomOffsetVal(Math.random()*10000-15000)
   );
   testCloud.material.opacity = 0.70;
   cloudParticles.push(testCloud);
   //scene.add(testCloud);
 }


 //BG
	loader.load('Three.js/images/gradient-bg.png', function (texture){
        //  var hdriEnv = new THREE.MeshBasicMaterial();
        //  hdriEnv.envMap = texture;
		scene.background = texture;
});


	
	
	///////////
	// VIDEO //
	///////////
	
	// create the video element
	video = document.createElement( 'video' );
	video.src = "Three.js/videos/ShelterStore - story_2.mp4";
	video.load(); // must call after setting/changing source
	
	videoImage = document.createElement( 'canvas' );
	videoImage.width = 1080;
	videoImage.height = 1920;

	videoImageContext = videoImage.getContext( '2d' );
	// background color if no video present
	var grd = videoImageContext.createLinearGradient(0, 0, 0, 1000);
	grd.addColorStop(0, "silver");
	grd.addColorStop(1, "white");

	videoImageContext.fillStyle = grd;
	videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );

	//create the cards
	let cardTextures = [];
	fetch('./json/cardTextures.json')
	.then(response => response.json())
	.then(data => createCards(data));




	const createCards = (data) => {
	for (let i = 0; i < data.length; i++) {
		
	cardGeo = new THREE.PlaneBufferGeometry( 108, 192);

	// videoTexture = new THREE.VideoTexture( videoImage );

	// videoTexture.minFilter = THREE.LinearFilter;
	// videoTexture.magFilter = THREE.LinearFilter;

	const backTexture = new THREE.TextureLoader(loadingManager).load(data[i].back);
	backTexture.minFilter = THREE.LinearFilter;
	backTexture.magFilter = THREE.LinearFilter;


	const frontTexture = new THREE.TextureLoader(loadingManager).load(data[i].front);
	frontTexture.minFilter = THREE.LinearFilter;
	frontTexture.magFilter = THREE.LinearFilter;

	var frontMaterial = new THREE.MeshStandardMaterial( { map: frontTexture, side:THREE.FrontSide,  } );
	var backMaterial = new THREE.MeshStandardMaterial( { map: backTexture, side: THREE.BackSide } );

	card = new THREE.Group();

	cardFront = new THREE.Mesh( cardGeo, frontMaterial );
	cardBack = new THREE.Mesh( cardGeo, backMaterial );

	card.add(cardFront);
	card.add(cardBack);

	card.position.set(
	centerPoint.x + Math.cos(radianInterval * i) * carrouselRadius
	,150,
	centerPoint.z + Math.sin(radianInterval * i) * carrouselRadius)

	card.rotation.y = 180*(Math.PI/180);

	card.lookAt(new THREE.Vector3(0,150,0));
	carrousel.add(card);

	var domEvents = new THREEx.DomEvents(camera, renderer.domElement);
	domEvents.addEventListener(card, 'click', onDocumentMouseDown, false);

	}
}

	scene.add(carrousel);
	carrousel.position.set(0,0,600);
	console.log(carrousel);


	camera.position.set(0,150,1500);
	//camera.lookAt(card.position);

function onDocumentMouseDown(event){

	let targetCard = event.target;
	console.log(`you clicked card ${event.target.uuid}`);
	lastClicked = event.target.uuid;

	if(lastClicked === targetCard.uuid  && targetCard.getWorldPosition().z > 1140){
				let rotationY = targetCard.rotation.y;
				console.log(targetCard.getWorldPosition());
				rotation = false;
				rotationY += 180*(Math.PI/180);
				var tweenRot = new TWEEN.Tween(targetCard.rotation).to({y: rotationY}, 500).start();
				tweenRot.easing(TWEEN.Easing.Quadratic.In);
				}
    
	// 	 var tween = new TWEEN.Tween(carrousel.position).to({x: 0, y:0, z:0}, 500, TWEEN.Easing.ElasticIn).start();
	//  tween.easing(TWEEN.Easing.Quadratic.In)

}

let scrollspeed = 0;
document.addEventListener('wheel', event => {
	scrollspeed = event.deltaY * (Math.PI/180) *0.2;
	carrousel.rotation.y += -0.5 * scrollspeed;
	rotation = true;
})
}

function animate(time) 
{
	 if(RESOURCES_LOADED == false){
		requestAnimationFrame( animate );

	
		 return;
	 }

	let sec = time*0.001;
	const rotSpeed = 45*(Math.PI/180);
    rot = sec * rotSpeed;

	//console.log(rot);

	if(playing = false){
		video.pause();
	}

	//floor movement
	floorTexture.offset.y -= .004;

	//cloud movement
	cloudParticles.forEach(p => {
      p.position.x -=0.5;
	  p.rotation.z -= 0.0001;
   });

   if(rotation == true){
   carrousel.rotation.y += 0.0001;
}

    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	if ( keyboard.pressed("s") ) // stop video
	{
		video.pause();
		video.currentTime = 0;
	}
	
	if ( keyboard.pressed("r") ) // rewind video
		video.currentTime = 0;
	
	//controls.update();
	TWEEN.update()
	stats.update();
}

function render(time) 
{	

	if ( video.readyState === video.HAVE_ENOUGH_DATA ) 
	{
		videoImageContext.drawImage( video, 0, 0 );
		if ( videoTexture ) 
			videoTexture.needsUpdate = true;
	}
	if(cardMaterial){
		cardMaterial.needsUpdate = true;
	}

	renderer.render( scene, camera );
}

</script>

</body>
</html>
